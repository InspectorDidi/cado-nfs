
/*

Run with
  magma ell:=$ELL nmaps:=$SMAPS sparsefile:=$SPARSE smfile:=$SM kerfile:=$KER linalg.mag

*/

COMPUTE_COMPLETE_KERNEL := true;
DEBUG := true;

ell := StringToInteger(ell);
nmaps := StringToInteger(nmaps);

SetNthreads(4);
SetVerbose("SparseMatrix", 1);

function ReadLineIndex(str)
    S := Split(str, " ");
    n := StringToInteger(S[1]);
    assert #S eq n+1;
    C := [];
    for i := 1 to n do
        A := Split(S[i+1], ":");
        Append(~C, [ StringToInteger(A[1], 16), StringToInteger(A[2]) ]);
    end for;
    return C;
end function;


function ReadLineSmall(str)
    S := Split(str, " ");
    n := StringToInteger(S[1]);
    assert #S eq n+1;
    C := [];
    for i := 1 to n do
        A := Split(S[i+1], ":");
        Append(~C, [ StringToInteger(A[1]), StringToInteger(A[2]) ]);
    end for;
    return C;
end function;

M := SparseMatrix();

// Main part
printf "Reading the sparse matrix %o...\n", sparsefile;
SmallFile := Read(sparsefile);
Lines := Split(SmallFile);
m, n := Explode(StringToIntegerSequence(Lines[1]));

for i := 1 to m do
    C := ReadLineSmall(Lines[i+1]);
    for j := 1 to #C do
        SetEntry(~M, i, 1+C[j][1], C[j][2]);
    end for;
end for;

// SM part
if nmaps gt 0 then
    printf "Reading the SM part %o...\n", smfile;
    SMFile := Read(smfile);
    Lines := Split(SMFile);
    mm := StringToIntegerSequence(Lines[1])[1];
    assert mm eq m;

    for i := 1 to m do
        C := StringToIntegerSequence(Lines[i+1]);
        assert #C ge nmaps;
        for j := 1 to nmaps do
            SetEntry(~M, i, n+j, C[j]);
        end for;
    end for;
end if;

// If the system is overdetermined, let's erase the last rows because
// Magma 2.20 (upto at least patch-level 4) has a bug.
/*
if NumberOfRows(M) gt NumberOfColumns(M) then
    for i := NumberOfColumns(M)+1 to NumberOfRows(M) do
        S := Support(M, i);
        for j in S do
            SetEntry(~M, i, j, 0);
        end for;
    end for;
end if;
*/

// Computing...
printf "Computing kernel...\n";


procedure CheckVectorInKernel(Mat, nrow, vector, l)
  for i in [1..nrow] do
    c := GF(l) ! 0;
    for j in Support (Mat, i) do
      c := c + vector[j]*Mat[i][j];
    end for;
    if c ne 0 then
      print "# Error", i-1, c;
    end if;
  end for;
end procedure;

if not COMPUTE_COMPLETE_KERNEL then
  time v := ModularSolution(M, ell : Lanczos := false);
  print "# Number of 0's in kernel vector:", #[x : x in Eltseq(v) | x eq 0];
  if DEBUG then
    printf "Check...\n";
    CheckVectorInKernel (M, m, v, ell);
  end if;
else
  N := ChangeRing(M, GF(ell));
  time K := NullspaceOfTranspose (N);
  d := Dimension(K);
  printf "# Dim(K)=%o\n", d;
  for v in Basis(K) do
    nbnz := #[x : x in Eltseq(v) | x ne 0];
    print "# Number of non-zeros in kernel vector:", nbnz;

    if DEBUG then
      CheckVectorInKernel (M, m, v, ell);
    end if;
  end for;
  v := Basis(K)[1];
end if;

if not DEBUG then
  printf "Write result to %o...\n", kerfile;
  SetOutputFile(kerfile: Overwrite:=true);
  for i := 1 to NumberOfColumns(M) do
    print v[i];
  end for;
  UnsetOutputFile();
end if;

if DEBUG then
  for i in [1..5] do
    printf "i=%o:", i;
    for j in Support (M, i) do printf " %o:%o", j-1, M[i][j]; end for;
    printf "\n";
  end for;
end if;

printf "Finished\n";
exit;
