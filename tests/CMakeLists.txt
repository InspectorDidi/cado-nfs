macro(build_test DSTFILE SRCFILE LIBRARIES)
    # Add a build target for the test binary
    add_executable("${DSTFILE}" "${SRCFILE}")
    target_link_libraries("${DSTFILE}" ${LIBRARIES})
endmacro(build_test)

macro(run_test NAME DSTFILE)
    # This add_test() call causes the ctest program to be called on the
    # current source and binary directories. The ctest program then builds
    # the DSTFILE binary by calling cmake (which we suppress here) and make,
    # and then runs DSTFILE
    add_test ("${NAME}" "${CMAKE_CTEST_COMMAND}"
              # Specify the source and build directories for the Cmake/make
              # steps that gets executed by CTest (except we suppress the
              # CMake step in this CTest run, but we still have to specify the
              # directories)
              --build-and-test "${CMAKE_CURRENT_SOURCE_DIR}"
                               "${CMAKE_CURRENT_BINARY_DIR}"

              # If CTest were to run Cmake, it should use same CMake generator
              # as we use in the parent Cmake. We suppress the CMake call, but
              # the "--build-generator" parameter is mandatory so we have to
              # specify it anyway. Without it, we get this error:
              # "--build-and-test requires that both the generator and 
              #  makeprogram be provided using the --build-generator and 
              #  --build-makeprogram command line options."
              --build-generator "${CMAKE_GENERATOR}"

              # Use same make program as the parent CMake.
              --build-makeprogram "${CMAKE_MAKE_PROGRAM}"

              # Do NOT run CMake. The CMakeCache.txt file generated by having
              # add_subdirectory() in the parent directories is fine, and
              # if we were to let CTest re-run CMake, we'd have to figure out
              # directory locations all over again - this way, we inherit
              # everything from the CMakeCache.txt generated by the parent
              # CMake.
              --build-nocmake

              # Normally, CTest runs "make clean" before building any target,
              # so that only the most recently built target would remain in
              # the build directory. I assume we don't want that, but want to
              # be able to run them manually as well. Do tell CTest not to do
              # "make clean."
              --build-noclean

              # When we build and run this test, build only the binary
              # required for this test
              --build-target "${DSTFILE}"

              # If any test fails, print its output to stdout.
              # ... except that does not actually work. When running the
              # test suite with
              # /usr/bin/ctest --force-new-ctest-process -V
              # then the debugging output shows --output-on-failure being
              # passed to the spawned ctest processes, but without -V, they
              # still don't print anything in case of failure. Maybe a bug.
              # To get output, we have to pass it via ARGS to "make test".
              --output-on-failure

              # And finally the binary that should be run as the actual test
              --test-command "${DSTFILE}" ${ARGN})
endmacro(run_test NAME DSTFILE)

# The SRCFILE parameter to this macro is the file name of the source file to
# build. The LIBRARIES parameter is any libraries that should be linked in.
# Any additional parameters are added to the command line of the test
# executable that gets run.
macro(build_and_run_test SRCFILE LIBRARIES)
    # The name of the binary executable is equal to the name of the source
    # file, minus the extension
    get_filename_component (DSTFILE "${SRCFILE}" NAME_WE)

    build_test ("${DSTFILE}" "${SRCFILE}" "${LIBRARIES}")
    # The name of the test here is the same as the name of the test
    # executable file
    run_test ("${DSTFILE}" "${DSTFILE}" ${ARGN})
endmacro(build_and_run_test)

include_directories("${CMAKE_CURRENT_SOURCE_DIR}")
add_library (tests STATIC test_iter.c tests_common.c)
target_link_libraries (tests ${gmp_libname})

build_test(test_tests_common test_tests_common.c tests)
run_test(tests_common_1 test_tests_common)
run_test(tests_common_2 test_tests_common -seed)
run_test(tests_common_3 test_tests_common -seed 1)
set_tests_properties(tests_common_3 PROPERTIES PASS_REGULAR_EXPRESSION "Using random seed=1")
run_test(tests_common_4 test_tests_common -seed a)
run_test(tests_common_5 test_tests_common -seed "")
set_tests_properties(tests_common_2 tests_common_4 tests_common_5 PROPERTIES WILL_FAIL 1)
run_test(tests_common_6 test_tests_common -iter 10)
set_tests_properties(tests_common_6 PROPERTIES PASS_REGULAR_EXPRESSION "Using 10 iterations")

build_and_run_test(test_iceildiv.c "")

add_subdirectory (utils)
add_subdirectory (sieve)
add_subdirectory (polyselect)
add_subdirectory (filter)
